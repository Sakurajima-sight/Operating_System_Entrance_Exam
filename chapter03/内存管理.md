P161
### 符号地址（Symbolic Address）解析

符号地址是一种以符号形式（而不是数字形式）表示内存地址的方法。这种方式有助于程序员更容易地理解和维护代码。符号地址通常在程序编写阶段使用，并且在编译或装载时会转换为实际的物理或逻辑地址。

#### 举例

以C语言为例，当你声明一个变量，比如：

```c
int x = 10; // 声明一个名为x的整数变量，并初始化为10
```

这里的`x`就是一个符号地址，代表这个整数变量在内存中的位置。

#### 在编译过程中的转换

编译器在编译代码时，会将这些符号地址转换成实际的内存地址。例如，在上面的例子中，变量`x`可能会被分配到物理内存地址`0x7fff5fbff74c`。

```c
// 逻辑视角
int x = 10; // 符号地址: x

// 编译后
// 实际物理地址: 0x7fff5fbff74c (这只是一个例子，实际地址会因系统而异)
```

#### 为什么使用符号地址

使用符号地址的主要优点是可读性和可维护性。程序员不需要记住复杂的内存地址，只需要记住变量名或函数名。

P165 
### 固定分区存储分配的局限性与问题

固定分区存储分配是一种最基础和简单的存储分配方法，通常用于多道程序设计。在这种方法中，物理内存被分为几个固定大小的分区，每个分区可以加载一个程序。

#### 无外部碎片但存储空间利用率低

虽然固定分区方法没有外部碎片（未被使用但不能被分配的内存块），但是它有以下几个问题，这些问题使其在存储空间利用率方面表现不佳：

1. **内部碎片问题**: 如果一个进程所需要的内存小于一个固定分区的大小，那么这个分区的剩余空间将被浪费，形成内部碎片。

2. **不灵活**: 固定分区的大小是预先设定的，这限制了它们能装载的程序大小。太大的程序无法装入任何分区，而太小的程序会造成内部碎片。

3. **无法实现多进程共享同一个主存区**: 在固定分区方案中，每个分区通常只能被一个进程使用。这是因为分区边界是固定的，没有机制允许两个或更多的进程在同一时刻共享一个分区。

4. **分区数量有限**: 系统资源有限，因此只能设定有限数量的分区。如果所有分区都被使用，新的进程将无法启动，即使总体上还有未使用的内存。

5. **程序大小限制**: 如果一个程序的大小超过单个分区的容量，那么这个程序将无法在这种方法下执行。

因为这些问题，固定分区方法通常只用于非常简单或者资源受限的系统。在现代操作系统中，更高级的内存管理技术（如动态分区、分页、分段等）通常会被使用，以提高内存利用率和系统性能。

P166
### 四种内存回收情况的解释与举例

回收内存是操作系统内存管理的一个重要环节。根据是否与前后相邻的空闲区合并，回收内存时可能有以下四种情况。

#### 情况1：回收区与前一空闲分区相邻

假设我们有以下空闲分区：

- 分区1: 始址 = 0x00, 大小 = 10KB

现在要回收一个分区，其始址为0x10，大小为10KB。

在这种情况下，回收的分区与分区1相邻。因此，我们会合并这两个分区，并更新分区1的大小为20KB（原10KB + 新10KB）。

#### 情况2：回收区与后一空闲分区相邻

假设我们有以下空闲分区：

- 分区3: 始址 = 0x40, 大小 = 20KB

假设我们有同样的三个空闲分区，现在要回收的分区始址为0x30，大小为10KB。

回收的分区与分区3相邻，所以我们将这两个分区合并，并更新分区3的始址为0x30和大小为30KB（原20KB + 新10KB）。

#### 情况3：回收区与前、后两个空闲分区都相邻

假设我们有以下空闲分区：

- 分区1: 始址 = 0x00, 大小 = 10KB
- 分区2: 始址 = 0x20, 大小 = 10KB
  
现在要回收一个分区，其始址为0x10，大小为10KB。

回收的分区与分区1和分区2都相邻，所以我们将这三个分区合并，更新分区1的大小为30KB，并取消分区2的表项。

#### 情况4：回收区没有相邻的空闲分区

假设我们有以下空闲分区：

- 分区1: 始址 = 0x00, 大小 = 10KB
- 分区2: 始址 = 0x80, 大小 = 10KB
- 
假设我们有同样的三个空闲分区，现在要回收的分区始址为0x60，大小为10KB。

这个回收区与任何现有的空闲分区都不相邻。在这种情况下，我们将为这个回收区新建一个表项，填写其始址（0x60）和大小（10KB），并将其插入空闲分区链中。

这四种情况涵盖了所有可能的内存回收场景，并通过合并相邻的空闲分区，有效地减少了内存碎片。\

P167
### 页表与地址结构的区别

在操作系统中，内存管理是一个复杂但重要的任务。为了有效管理内存，很多现代操作系统采用了分页机制。这里涉及到几个重要概念：页表、页表项、逻辑地址（或虚拟地址）和物理地址。

#### 页表和页表项

- **页表**：是一个数据结构，用于存储逻辑页和物理页（或物理块）的映射关系。
- **页表项**：页表中的一个元素，通常由两部分构成：页号和块号。
  - 页号：表示这是哪个逻辑页。
  - 块号：表示这个逻辑页映射到物理内存中的哪个块。

#### 地址结构

- **逻辑地址（或虚拟地址）**：由CPU生成，包括两部分。
  - 页号：用于在页表中查找对应的页表项。
  - 页内偏移：表示在这个页（或块）内的哪个位置。
  
- **物理地址**：用于在实际的物理内存中定位数据，通常由页表项的块号和逻辑地址的页内偏移共同组成。

#### 举例解释

假设我们有以下的设置：

- 逻辑地址为 `1100`, 其中页号是 `1`, 页内偏移是 `100`。
- 在页表中，页号 `1` 对应的块号是 `4`。

通过查找页表，我们可以得到逻辑页 `1` 对应于物理块 `4`。因此，物理地址将是块号 `4` 和页内偏移 `100` 的组合，通常这个组合是某种形式的拼接或者其他运算，具体依赖于系统实现。

例如，如果每个块的大小是 `256` 字节，那么物理地址可能是 `4 * 256 + 100 = 1100`。

通过这个例子，你应该能明白页表、页表项以及逻辑地址和物理地址之间的关系和区别。希望这能帮助你更好地理解这个概念。

P170
### 逻辑地址空间与页表项数量

在计算机的虚拟存储器系统中，逻辑地址（或虚拟地址）空间是由多个页面组成的。这里，逻辑地址空间为 32 位，页面大小为 4KB。

#### 逻辑地址空间的大小

32位逻辑地址意味着可以寻址 \(2^{32}\) 个地址位置，这等于 4GB。

#### 每个页面的大小

页面大小为 4KB，也就是 \(2^{12}\) 字节。

#### 页面数量

为了映射整个 4GB 的逻辑地址空间，需要的页面数量是：

\[
\frac{2^{32} \text{ 字节}}{2^{12} \text{ 字节/页}} = 2^{20} \text{ 页}
\]

也就是约 100 万个页面。

#### 页表项的数量与大小

因为每个页面都需要一个页表项来存储其对应的物理地址，所以也需要 \(2^{20}\) 个页表项。

每个页表项的大小是 4B。

#### 页表所需的内存

因此，每个进程的页表所需的内存大小是：

\[
2^{20} \text{ 页表项} \times 4 \text{ 字节/页表项} = 2^{22} \text{ 字节} = 4 \text{ MB}
\]

#### 为什么需要连续的主存空间？

一些传统的页表实现（例如单级页表）要求页表在物理内存中是连续的，以简化地址转换的硬件实现。不过，现代操作系统通常使用多级页表（如二级或多级页表）来避免这种连续性要求，从而更有效地使用物理内存。

P170
### 二级页表和内存效率提升

在计算机系统中，内存管理是一个关键的部分，特别是在分页系统中。二级页表（或多级页表）是一种用于提高内存利用率和管理灵活性的技术。

#### 为什么一个页面可以存储 \(2^{10} = 1024\) 个页表项

在一个4KB（4096字节）的页面中，如果每个页表项（Page Table Entry，PTE）占用4字节，那么一个页面可以容纳 \( \frac{4096}{4} = 1024 \) 个页表项。这里的4字节是一个常见的页表项大小，通常用于存储实际物理页面的地址和其他一些状态信息。

\[
\text{页表项数量} = \frac{\text{页面大小（字节）}}{\text{每个页表项的大小（字节）}} = \frac{4096}{4} = 1024
\]

#### 二级页表解决方案

在给定的例子中，一个40MB的进程需要一个40KB的页表，这等于10个4KB的页面。为了避免加载这10个页面，我们引入一个上级（二级）页表。

这个上级页表只需要10个页表项来映射这10个主页表页面。既然一个4KB的页面可以存储1024个页表项（如上所解释），上级页表只需要一个页面就足够了。

#### 优势

1. **内存效率提高**：你不再需要将全部的10个主页表页面加载到内存中。只需要加载1个上级页表页面和部分主页表页面。
2. **灵活性提高**：在大多数使用场景下，进程只会访问其地址空间的一小部分，因此只需要加载这部分对应的主页表即可。二级页表使这种动态加载和卸载成为可能。

通过使用二级页表，我们不仅提高了内存的使用效率，还提高了系统的灵活性和管理能力。

P173
### 分页管理：页号与页内偏移

在操作系统中，分页管理是一种内存管理模式，其中物理内存被划分为固定大小的单元，称为“页”。每个进程的虚拟地址空间也被分成同样大小的“页”。当进程访问一个虚拟地址时，这个地址会被转换为一个页号和一个页内偏移。

#### 页号与页内偏移

- **页号（Page Number）**: 用于索引页表，以找到相应的物理页帧。
  
- **页内偏移（Offset）**: 用于在找到的物理页帧内进行定位，以找到具体的数据。

#### 判断逻辑

- **页号越界**: 如果一个进程尝试访问一个不属于它的页，即该页号不在进程的页表中，这称为“页号越界”。

- **页内偏移越界**: 理论上，由于页内偏移是用于在一个给定的页中进行定位，因此它的最大值是这个页的大小减一（页通常是 4KB 或 8KB）。因此，页面内偏移通常不可能越界。

#### 举例说明

假设我们有一个系统，其中每个页的大小为 4KB。

1. 虚拟地址： `0x00002013`
  
2. 页号 = `0x00002013 / 4096` = `0x00000008`
  
3. 页内偏移 = `0x00002013 % 4096` = `0x0013`

在这个例子中：

- 页号是 8，我们需要检查这是否在进程的页表范围内。如果不是，则这是一个“页号越界”的错误。

- 页内偏移是 0x0013，既然每个页的大小为 4096 字节（0x1000），页内偏移从 0 到 0x0FFF 都是有效的。所以，这里的偏移 0x0013 是有效的，不可能“越界”。

通过这个例子，您可以看出，只需要检查页号是否越界，而不需要检查页内偏移，因为页内偏移是基于页大小的，不可能越界。

P173
### 段内偏移越界的原因

在分段内存管理中，每一个段都有一个起始地址和长度。当你尝试访问一个内存地址，操作系统会检查这个地址是否在段的边界内。如果超出，那就是段内偏移越界。

以下是可能导致段内偏移越界的几个原因：

1. **程序错误**: 如果程序试图访问一个不属于它的内存地址，这通常是因为编程错误。

2. **动态内存分配**: 在使用诸如`malloc`或`new`等动态内存分配函数时，如果程序没有正确地管理这些动态分配的内存，就可能导致越界。

3. **数组越界**: 在C或C++中，数组是没有边界检查的。如果你试图访问数组的一个不存在的元素，这就可能导致越界。

4. **指针算术**: 错误的指针算术也是常见的导致问题的原因。例如，对一个指针进行递增操作，使它超出了它本应指向的内存块。

5. **缓冲区溢出**: 当向一个缓冲区（如数组）写入数据而没有正确地检查边界时，也可能发生越界。这通常是缓冲区溢出攻击的一个常见原因。

6. **未初始化的或野指针**: 使用未初始化的指针或已经释放（`free`或`delete`）的指针，也可能导致越界。

7. **并发问题**: 在多线程环境下，如果没有正确地同步，两个线程可能会尝试修改同一个内存位置，可能导致越界。

理解这些原因有助于编写更安全、更健壮的代码，也有助于更好地理解操作系统如何管理内存。

P173
### 分段和分页管理的地址空间区别

#### 分段管理：二维地址空间

在分段管理中，地址由两部分组成：段号和段内偏移。因此，可以将它看作是二维的。例如，如果有一个程序有3个不同的段（代码段、数据段、堆栈段），那么这些段分别可以被标记为段号0、1和2。

- 段0（代码段）：偏移从0到999
- 段1（数据段）：偏移从0到799
- 段2（堆栈段）：偏移从0到199

在这个设置下，地址（1,400）指的是数据段（段号1）中偏移为400的位置。所以，这里我们需要两个维度：一个是段号，另一个是段内偏移。

#### 分页管理：一维地址空间

在分页管理中，整个地址空间被均匀地分割成固定大小的页，而每个页有一个唯一的页号。页内偏移是页内的地址。这种管理方式下，只需要一个维度，即线性地址空间。

例如，假设有一个地址空间范围从0到4095，且每个页的大小为1024字节。那么：

- 页0：偏移从0到1023
- 页1：偏移从0到1023
- 页2：偏移从0到1023
- 页3：偏移从0到1023

在这个例子中，地址2000实际上可以通过一维坐标唯一确定，它位于页1中，偏移为976。

因此，分段管理的地址空间是二维的，因为需要段号和段内偏移两个信息来定位一个地址；而分页管理的地址空间是一维的，因为一个线性地址就足以定位实际的物理地址。